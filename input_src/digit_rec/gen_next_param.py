import json, math, os, sys
import argparse
import re
from collections import Counter
sys.path.append('../')
from code_gen_util import return_operator_io_argument_dict_local, return_operator_inst_dict_local, return_operator_connect_list_local,\
                          return_operator_io_type_and_width, needs_write_param, needs_write_filedata, sorted_op_list_backward, divide_ops,\
                          perform_merging, merge_op_list


########################
## Benchmark-specific ##
########################

def gen_update_knn_i1_func():
    func_str_list = []
    func_str_list.append('#include "../host/typedefs.h"')
    func_str_list.append('')
    func_str_list.append('')
    func_str_list.append('static int popcount(WholeDigitType x)')
    func_str_list.append('{')
    func_str_list.append('  // most straightforward implementation')
    func_str_list.append('  // actually not bad on FPGA')
    func_str_list.append('  int cnt = 0;')
    func_str_list.append('  for (int i = 0; i < IMAGE_SIZE; i ++ )')
    func_str_list.append('  {')
    func_str_list.append('#pragma HLS unroll')
    func_str_list.append('    cnt = cnt + x(i,i);')
    func_str_list.append('  }')
    func_str_list.append('  return cnt;')
    func_str_list.append('}')
    func_str_list.append('')
    func_str_list.append('static void update_knn( WholeDigitType test_inst, WholeDigitType train_inst, int min_distances[K_CONST] )')
    func_str_list.append('{')
    func_str_list.append('#pragma HLS inline')
    func_str_list.append('#pragma HLS array_partition variable=min_distances complete dim=0')
    func_str_list.append('')
    func_str_list.append('')
    func_str_list.append('  // Compute the difference using XOR')
    func_str_list.append('  WholeDigitType diff = test_inst ^ train_inst;')
    func_str_list.append('')
    func_str_list.append('  int dist = 0;')
    func_str_list.append('')
    func_str_list.append('  dist = popcount(diff);')
    func_str_list.append('')
    func_str_list.append('  int max_dist = 0;')
    func_str_list.append('  int max_dist_id = 0;')
    func_str_list.append('  int k = 0;')
    func_str_list.append('')
    func_str_list.append('  // Find the max distance')
    func_str_list.append('  FIND_MAX_DIST: for ( int k = 0; k < K_CONST; ++k )')
    func_str_list.append('  {')
    func_str_list.append('    if ( min_distances[k] > max_dist )')
    func_str_list.append('    {')
    func_str_list.append('      max_dist = min_distances[k];')
    func_str_list.append('      max_dist_id = k;')
    func_str_list.append('    }')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('  // Replace the entry with the max distance')
    func_str_list.append('  if ( dist < max_dist )')
    func_str_list.append('    min_distances[max_dist_id] = dist;')
    func_str_list.append('')
    func_str_list.append('  return;')
    func_str_list.append('}')
    func_str_list.append('')
    func_str_list.append('')
    func_str_list.append('static void knn_vote_small(int knn_set[OP_SIZE * K_CONST],')
    func_str_list.append('                           int min_distance_list[K_CONST],')
    func_str_list.append('                           int label_list[K_CONST],')
    func_str_list.append('                           LabelType label_in)')
    func_str_list.append('{')
    func_str_list.append('#pragma HLS inline')
    func_str_list.append('#pragma HLS array_partition variable=knn_set complete dim=0')
    func_str_list.append('// final K nearest neighbors')
    func_str_list.append('#pragma HLS array_partition variable=min_distance_list complete dim=0')
    func_str_list.append('// labels for the K nearest neighbors')
    func_str_list.append('#pragma HLS array_partition variable=label_list complete dim=0')
    func_str_list.append('')
    func_str_list.append('  int pos = 1000;')
    func_str_list.append('')
    func_str_list.append('  // go through all the lanes')
    func_str_list.append('  // do an insertion sort to keep a sorted neighbor list')
    func_str_list.append('  LANES: for (int i = 0; i < OP_SIZE; i ++ )')
    func_str_list.append('  {')
    func_str_list.append('    INSERTION_SORT_OUTER: for (int j = 0; j < K_CONST; j ++ )')
    func_str_list.append('    {')
    func_str_list.append('      #pragma HLS pipeline')
    func_str_list.append('      pos = 1000;')
    func_str_list.append('      INSERTION_SORT_INNER: for (int r = 0; r < K_CONST; r ++ )')
    func_str_list.append('      {')
    func_str_list.append('        #pragma HLS unroll')
    func_str_list.append('        pos = ((knn_set[i*K_CONST+j] < min_distance_list[r]) && (pos > K_CONST)) ? r : pos;')
    func_str_list.append('      }')
    func_str_list.append('')
    func_str_list.append('      INSERT: for (int r = K_CONST ;r > 0; r -- )')
    func_str_list.append('      {')
    func_str_list.append('        #pragma HLS unroll')
    func_str_list.append('        if(r-1 > pos)')
    func_str_list.append('        {')
    func_str_list.append('          min_distance_list[r-1] = min_distance_list[r-2];')
    func_str_list.append('          label_list[r-1] = label_list[r-2];')
    func_str_list.append('        }')
    func_str_list.append('        else if (r-1 == pos)')
    func_str_list.append('        {')
    func_str_list.append('          min_distance_list[r-1] = knn_set[i*K_CONST+j];')
    func_str_list.append('          label_list[r-1] = label_in;')
    func_str_list.append('        }')
    func_str_list.append('      }')
    func_str_list.append('    }')
    func_str_list.append('  }')
    func_str_list.append('}')
    func_str_list.append('')
    func_str_list.append('')
    func_str_list.append('')
    func_str_list.append('#define NUM1 1')
    func_str_list.append('void update_knn_i1(hls::stream<ap_uint<256> > & Input_1,')
    func_str_list.append('                   hls::stream<ap_uint<32> > & Output_1)')
    func_str_list.append('{')
    func_str_list.append('#pragma HLS INTERFACE axis register port=Input_1')
    func_str_list.append('#pragma HLS INTERFACE axis register port=Output_1')
    func_str_list.append('')
    func_str_list.append('static WholeDigitType training_set [NUM_TRAINING / NUM_OPS];')
    func_str_list.append('const int unroll_factor = OP_SIZE;')
    func_str_list.append('#pragma HLS array_partition variable=training_set block factor=unroll_factor dim=0')
    func_str_list.append('')
    func_str_list.append('static WholeDigitType test_instance;')
    func_str_list.append('bit32 tmp;')
    func_str_list.append('')
    func_str_list.append('static int knn_set[K_CONST*OP_SIZE];')
    func_str_list.append('#pragma HLS array_partition variable=knn_set complete dim=0')
    func_str_list.append('')
    func_str_list.append('static ap_uint<256> in_tmp;')
    func_str_list.append('')
    func_str_list.append('WholeDigitType data_temp;')
    func_str_list.append('static int index = 0;')
    func_str_list.append('')
    func_str_list.append('  if (index == 0)')
    func_str_list.append('  {')
    func_str_list.append('    //Store the local training set')
    func_str_list.append('    STORE_LOCAL: for(int i = 0; i < NUM_TRAINING / NUM_OPS / 2; i++)')
    func_str_list.append('    {')
    func_str_list.append('#pragma HLS pipeline')
    func_str_list.append('      in_tmp = Input_1.read();')
    func_str_list.append('      training_set[2*i  ](255, 224) =in_tmp(31,    0);')
    func_str_list.append('      training_set[2*i  ](223, 192) =in_tmp(63,   32);')
    func_str_list.append('      training_set[2*i  ](191, 160) =in_tmp(95,   64);')
    func_str_list.append('      training_set[2*i  ](159, 128) =in_tmp(127,  96);')
    func_str_list.append('      training_set[2*i  ](127,  96) =in_tmp(159, 128);')
    func_str_list.append('      training_set[2*i  ](95,   64) =in_tmp(191, 160);')
    func_str_list.append('      training_set[2*i  ](63,   32) =in_tmp(223, 192);')
    func_str_list.append('      training_set[2*i  ](31,    0) =in_tmp(255, 224);')
    func_str_list.append('')
    func_str_list.append('      in_tmp = Input_1.read();')
    func_str_list.append('      training_set[2*i+1](255, 224) =in_tmp(31,    0);')
    func_str_list.append('      training_set[2*i+1](223, 192) =in_tmp(63,   32);')
    func_str_list.append('      training_set[2*i+1](191, 160) =in_tmp(95,   64);')
    func_str_list.append('      training_set[2*i+1](159, 128) =in_tmp(127,  96);')
    func_str_list.append('      training_set[2*i+1](127,  96) =in_tmp(159, 128);')
    func_str_list.append('      training_set[2*i+1](95,   64) =in_tmp(191, 160);')
    func_str_list.append('      training_set[2*i+1](63,   32) =in_tmp(223, 192);')
    func_str_list.append('      training_set[2*i+1](31,    0) =in_tmp(255, 224);')
    func_str_list.append('    }')
    func_str_list.append('')
    func_str_list.append('    //Transit the training sets for other pages')
    func_str_list.append('    TRANSFER_LOOP: for(int i = 0; i < NUM_TRAINING / NUM_OPS * (NUM_OPS - NUM1) / 2; i++)')
    func_str_list.append('    {')
    func_str_list.append('#pragma HLS pipeline')
    func_str_list.append('      in_tmp = Input_1.read();')
    func_str_list.append('      tmp(31, 0) = in_tmp(31,    0); Output_1.write(tmp);')
    func_str_list.append('      tmp(31, 0) = in_tmp(63,   32); Output_1.write(tmp);')
    func_str_list.append('      tmp(31, 0) = in_tmp(95,   64); Output_1.write(tmp);')
    func_str_list.append('      tmp(31, 0) = in_tmp(127,  96); Output_1.write(tmp);')
    func_str_list.append('      tmp(31, 0) = in_tmp(159, 128); Output_1.write(tmp);')
    func_str_list.append('      tmp(31, 0) = in_tmp(191, 160); Output_1.write(tmp);')
    func_str_list.append('      tmp(31, 0) = in_tmp(223, 192); Output_1.write(tmp);')
    func_str_list.append('      tmp(31, 0) = in_tmp(255, 224); Output_1.write(tmp);')
    func_str_list.append('')
    func_str_list.append('      in_tmp = Input_1.read();')
    func_str_list.append('      tmp(31, 0) = in_tmp(31,    0); Output_1.write(tmp);')
    func_str_list.append('      tmp(31, 0) = in_tmp(63,   32); Output_1.write(tmp);')
    func_str_list.append('      tmp(31, 0) = in_tmp(95,   64); Output_1.write(tmp);')
    func_str_list.append('      tmp(31, 0) = in_tmp(127,  96); Output_1.write(tmp);')
    func_str_list.append('      tmp(31, 0) = in_tmp(159, 128); Output_1.write(tmp);')
    func_str_list.append('      tmp(31, 0) = in_tmp(191, 160); Output_1.write(tmp);')
    func_str_list.append('      tmp(31, 0) = in_tmp(223, 192); Output_1.write(tmp);')
    func_str_list.append('      tmp(31, 0) = in_tmp(255, 224); Output_1.write(tmp);')
    func_str_list.append('    }')
    func_str_list.append('    index = 1;')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('  in_tmp = Input_1.read();')
    func_str_list.append('  test_instance(255, 224) = in_tmp(31,    0);')
    func_str_list.append('  test_instance(223, 192) = in_tmp(63,   32);')
    func_str_list.append('  test_instance(191, 160) = in_tmp(95,   64);')
    func_str_list.append('  test_instance(159, 128) = in_tmp(127,  96);')
    func_str_list.append('  test_instance(127,  96) = in_tmp(159, 128);')
    func_str_list.append('  test_instance(95,   64) = in_tmp(191, 160);')
    func_str_list.append('  test_instance(63,   32) = in_tmp(223, 192 );')
    func_str_list.append('  test_instance(31,    0) = in_tmp(255, 224);')
    func_str_list.append('  tmp(31,0) = test_instance(255, 224);')
    func_str_list.append('  Output_1.write(tmp);')
    func_str_list.append('  tmp(31,0) = test_instance(223, 192);')
    func_str_list.append('  Output_1.write(tmp);')
    func_str_list.append('  tmp(31,0) = test_instance(191, 160);')
    func_str_list.append('  Output_1.write(tmp);')
    func_str_list.append('  tmp(31,0) = test_instance(159, 128);')
    func_str_list.append('  Output_1.write(tmp);')
    func_str_list.append('  tmp(31,0) = test_instance(127,  96);')
    func_str_list.append('  Output_1.write(tmp);')
    func_str_list.append('  tmp(31,0) = test_instance(95,   64);')
    func_str_list.append('  Output_1.write(tmp);')
    func_str_list.append('  tmp(31,0) = test_instance(63,   32);')
    func_str_list.append('  Output_1.write(tmp);')
    func_str_list.append('  tmp(31,0) = test_instance(31,    0);')
    func_str_list.append('  Output_1.write(tmp);')
    func_str_list.append('  ')
    func_str_list.append('')
    func_str_list.append('  int min_distance_list[K_CONST];')
    func_str_list.append('#pragma HLS array_partition variable=min_distance_list complete dim=0')
    func_str_list.append('')
    func_str_list.append('  int label_list[K_CONST];')
    func_str_list.append('#pragma HLS array_partition variable=label_list complete dim=0')
    func_str_list.append('')
    func_str_list.append('')
    func_str_list.append('  for(int i=0; i<K_CONST; i++)')
    func_str_list.append('  {')
    func_str_list.append('#pragma HLS unroll')
    func_str_list.append('    min_distance_list[i] = IMAGE_SIZE;')
    func_str_list.append('    label_list[i] = 0;')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('  // Initialize the knn set')
    func_str_list.append('  SET_KNN_SET: for ( int i = 0; i < K_CONST * OP_SIZE ; ++i )')
    func_str_list.append('  {')
    func_str_list.append('#pragma HLS unroll')
    func_str_list.append('    // Note that the max distance is 256')
    func_str_list.append('    knn_set[i] = IMAGE_SIZE;')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('  TRAINING_LOOP : for ( int i = 0; i < NUM_TRAINING / PAR_FACTOR; ++i )')
    func_str_list.append('  {')
    func_str_list.append('    #pragma HLS pipeline')
    func_str_list.append('    LANES : for ( int j = 0; j < OP_SIZE; j++ )')
    func_str_list.append('    {')
    func_str_list.append('      #pragma HLS unroll')
    func_str_list.append('      WholeDigitType training_instance = training_set[j * NUM_TRAINING / PAR_FACTOR + i];')
    func_str_list.append('      update_knn( test_instance, training_instance, &knn_set[j * K_CONST] );')
    func_str_list.append('    }')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('')
    func_str_list.append('  //update min_distance_list and label_list according to the new knn_set')
    func_str_list.append('  LabelType label_in = 0;')
    func_str_list.append('  knn_vote_small(knn_set, min_distance_list, label_list, label_in);')
    func_str_list.append('')
    func_str_list.append('  OutputTmpType output_tmp1, output_tmp2;')
    func_str_list.append('')
    func_str_list.append('  for(int i=0; i<K_CONST; i++)')
    func_str_list.append('  {')
    func_str_list.append('#pragma HLS unroll')
    func_str_list.append('    output_tmp1(i*32+31, i*32) = min_distance_list[i];')
    func_str_list.append('    output_tmp2(i*32+31, i*32) = label_list[i];')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('')
    func_str_list.append('  for(int i=OutputTmpWidth-1; i>0; i=i-32){')
    func_str_list.append('    tmp(31,0) = output_tmp1(i,i-31);')
    func_str_list.append('    Output_1.write(tmp);')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('  for(int i=OutputTmpWidth-1; i>0; i=i-32){')
    func_str_list.append('    tmp(31,0) = output_tmp2(i,i-31);')
    func_str_list.append('    Output_1.write(tmp);')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('  index++;')
    func_str_list.append('  return;')
    func_str_list.append('}')
    return 'update_knn_i1', "\n".join(func_str_list)

def gen_update_knn_i1_header():
    func_str_list = []
    func_str_list.append('void update_knn_i1(')
    func_str_list.append('    hls::stream<ap_uint<256>> & Input_1,')
    func_str_list.append('    hls::stream<ap_uint<32>> & Output_1')
    func_str_list.append('    );')
    func_str_list.append('#pragma map_target = HW')
    return 'update_knn_i1', "\n".join(func_str_list)

def gen_update_knn_iN_func(N):
    func_str_list = []
    func_str_list.append('#include "../host/typedefs.h"')
    func_str_list.append('')
    func_str_list.append('')
    func_str_list.append('static int popcount(WholeDigitType x)')
    func_str_list.append('{')
    func_str_list.append('  // most straightforward implementation')
    func_str_list.append('  // actually not bad on FPGA')
    func_str_list.append('  int cnt = 0;')
    func_str_list.append('  for (int i = 0; i < 256; i ++ )')
    func_str_list.append('  {')
    func_str_list.append('#pragma HLS unroll')
    func_str_list.append('    cnt = cnt + x(i, i);')
    func_str_list.append('  }')
    func_str_list.append('  return cnt;')
    func_str_list.append('}')
    func_str_list.append('')
    func_str_list.append('static void update_knn( WholeDigitType test_inst, WholeDigitType train_inst, int min_distances[K_CONST] )')
    func_str_list.append('{')
    func_str_list.append('#pragma HLS inline')
    func_str_list.append('#pragma HLS array_partition variable=min_distances complete dim=0')
    func_str_list.append('')
    func_str_list.append('')
    func_str_list.append('  // Compute the difference using XOR')
    func_str_list.append('  WholeDigitType diff = test_inst ^ train_inst;')
    func_str_list.append('')
    func_str_list.append('  int dist = 0;')
    func_str_list.append('')
    func_str_list.append('  dist = popcount(diff);')
    func_str_list.append('')
    func_str_list.append('  int max_dist = 0;')
    func_str_list.append('  int max_dist_id = 0;')
    func_str_list.append('  int k = 0;')
    func_str_list.append('')
    func_str_list.append('  // Find the max distance')
    func_str_list.append('  FIND_MAX_DIST: for ( int k = 0; k < K_CONST; ++k )')
    func_str_list.append('  {')
    func_str_list.append('    if ( min_distances[k] > max_dist )')
    func_str_list.append('    {')
    func_str_list.append('      max_dist = min_distances[k];')
    func_str_list.append('      max_dist_id = k;')
    func_str_list.append('    }')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('  // Replace the entry with the max distance')
    func_str_list.append('  if ( dist < max_dist )')
    func_str_list.append('    min_distances[max_dist_id] = dist;')
    func_str_list.append('')
    func_str_list.append('  return;')
    func_str_list.append('}')
    func_str_list.append('')
    func_str_list.append('')
    func_str_list.append('static void knn_vote_small(int knn_set[OP_SIZE * K_CONST],')
    func_str_list.append('                           int min_distance_list[K_CONST],')
    func_str_list.append('                           int label_list[K_CONST],')
    func_str_list.append('                           LabelType label_in)')
    func_str_list.append('{')
    func_str_list.append('#pragma HLS inline')
    func_str_list.append('#pragma HLS array_partition variable=knn_set complete dim=0')
    func_str_list.append('// final K nearest neighbors')
    func_str_list.append('#pragma HLS array_partition variable=min_distance_list complete dim=0')
    func_str_list.append('// labels for the K nearest neighbors')
    func_str_list.append('#pragma HLS array_partition variable=label_list complete dim=0')
    func_str_list.append('')
    func_str_list.append('  int pos = 1000;')
    func_str_list.append('')
    func_str_list.append('  // go through all the lanes')
    func_str_list.append('  // do an insertion sort to keep a sorted neighbor list')
    func_str_list.append('  LANES: for (int i = 0; i < OP_SIZE; i ++ )')
    func_str_list.append('  {')
    func_str_list.append('    INSERTION_SORT_OUTER: for (int j = 0; j < K_CONST; j ++ )')
    func_str_list.append('    {')
    func_str_list.append('      #pragma HLS pipeline')
    func_str_list.append('      pos = 1000;')
    func_str_list.append('      INSERTION_SORT_INNER: for (int r = 0; r < K_CONST; r ++ )')
    func_str_list.append('      {')
    func_str_list.append('        #pragma HLS unroll')
    func_str_list.append('        pos = ((knn_set[i*K_CONST+j] < min_distance_list[r]) && (pos > K_CONST)) ? r : pos;')
    func_str_list.append('      }')
    func_str_list.append('')
    func_str_list.append('      INSERT: for (int r = K_CONST ;r > 0; r -- )')
    func_str_list.append('      {')
    func_str_list.append('        #pragma HLS unroll')
    func_str_list.append('        if(r-1 > pos)')
    func_str_list.append('        {')
    func_str_list.append('          min_distance_list[r-1] = min_distance_list[r-2];')
    func_str_list.append('          label_list[r-1] = label_list[r-2];')
    func_str_list.append('        }')
    func_str_list.append('        else if (r-1 == pos)')
    func_str_list.append('        {')
    func_str_list.append('          min_distance_list[r-1] = knn_set[i*K_CONST+j];')
    func_str_list.append('          label_list[r-1] = label_in;')
    func_str_list.append('        }')
    func_str_list.append('      }')
    func_str_list.append('    }')
    func_str_list.append('  }')
    func_str_list.append('}')
    func_str_list.append('')
    func_str_list.append('')
    func_str_list.append('#define NUM' + str(N) + ' ' + str(N))
    func_str_list.append('void update_knn_i' + str(N) + '(hls::stream<ap_uint<32> > & Input_1, hls::stream<ap_uint<32> > & Output_1)')
    func_str_list.append('{')
    func_str_list.append('#pragma HLS INTERFACE axis register port=Input_1')
    func_str_list.append('#pragma HLS INTERFACE axis register port=Output_1')
    func_str_list.append('')
    func_str_list.append('static WholeDigitType training_set [NUM_TRAINING / NUM_OPS];')
    func_str_list.append('const int unroll_factor = OP_SIZE;')
    func_str_list.append('#pragma HLS array_partition variable=training_set block factor=unroll_factor dim=0')
    func_str_list.append('')
    func_str_list.append('static WholeDigitType test_instance;')
    func_str_list.append('')
    func_str_list.append('')
    func_str_list.append('static int knn_set[K_CONST*OP_SIZE];')
    func_str_list.append('#pragma HLS array_partition variable=knn_set complete dim=0')
    func_str_list.append('')
    func_str_list.append('WholeDigitType data_temp;')
    func_str_list.append('static int index = 0;')
    func_str_list.append('bit32 tmp;')
    func_str_list.append('')
    func_str_list.append('')
    func_str_list.append('  if (index == 0)')
    func_str_list.append('  {')
    func_str_list.append('    //Store the local training set')
    func_str_list.append('    STORE_LOCAL: for(int i = 0; i < NUM_TRAINING / NUM_OPS; i++)')
    func_str_list.append('    {')
    func_str_list.append('#pragma HLS pipeline')
    func_str_list.append('    for(int j=IMAGE_WIDTH-1; j>0; j=j-32){')
    func_str_list.append('      training_set[i](j,j-31) = Input_1.read();')
    func_str_list.append('    }')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('  //Transit the training sets for other pages')
    func_str_list.append('  TRANSFER_LOOP: for(int i = 0; i < NUM_TRAINING / NUM_OPS * (NUM_OPS - NUM' + str(N) + '); i++)')
    func_str_list.append('  {')
    func_str_list.append('#pragma HLS pipeline')
    func_str_list.append('    for(int j=IMAGE_WIDTH-1; j>0; j=j-32){')
    func_str_list.append('      data_temp(j,j-31) = Input_1.read();')
    func_str_list.append('    }')
    func_str_list.append('')
    func_str_list.append('    bit32 tmp;')
    func_str_list.append('    for(int j=IMAGE_WIDTH-1; j>0; j=j-32){')
    func_str_list.append('      tmp(31, 0) = data_temp.range(j,j-31);')
    func_str_list.append('      Output_1.write(tmp);')
    func_str_list.append('    }')
    func_str_list.append('  }')
    func_str_list.append('    index = 1;')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('  for(int i=IMAGE_WIDTH-1; i>0; i=i-32){')
    func_str_list.append('    test_instance(i,i-31) = Input_1.read();')
    func_str_list.append('  }')
    func_str_list.append('  for(int i=IMAGE_WIDTH-1; i>0; i=i-32){')
    func_str_list.append('    tmp(31, 0) = test_instance.range(i,i-31);')
    func_str_list.append('    Output_1.write(tmp);')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('  int min_distance_list[K_CONST];')
    func_str_list.append('  int label_list[K_CONST];')
    func_str_list.append('')
    func_str_list.append('  OutputTmpType input_tmp1, input_tmp2;')
    func_str_list.append('')
    func_str_list.append('  for(int i=OutputTmpWidth-1; i>0; i=i-32){')
    func_str_list.append('    input_tmp1(i,i-31) = Input_1.read();')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('  for(int i=OutputTmpWidth-1; i>0; i=i-32){')
    func_str_list.append('    input_tmp2(i,i-31) = Input_1.read();')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('')
    func_str_list.append('  for(int i=0; i<K_CONST; i++)')
    func_str_list.append('  {')
    func_str_list.append('#pragma HLS unroll')
    func_str_list.append('    min_distance_list[i] = (int) input_tmp1(i*32+31, i*32);')
    func_str_list.append('    label_list[i] = (int) input_tmp2(i*32+31, i*32);')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('  // Initialize the knn set')
    func_str_list.append('  SET_KNN_SET: for ( int i = 0; i < K_CONST * OP_SIZE ; ++i )')
    func_str_list.append('  {')
    func_str_list.append('#pragma HLS unroll')
    func_str_list.append('    // Note that the max distance is 256')
    func_str_list.append('    knn_set[i] = 256;')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('  TRAINING_LOOP : for ( int i = 0; i < NUM_TRAINING / PAR_FACTOR; ++i )')
    func_str_list.append('  {')
    func_str_list.append('#pragma HLS pipeline')
    func_str_list.append('    LANES : for ( int j = 0; j < OP_SIZE; j++ )')
    func_str_list.append('    {')
    func_str_list.append('#pragma HLS unroll')
    func_str_list.append('      WholeDigitType training_instance = training_set[j * NUM_TRAINING / PAR_FACTOR + i];')
    func_str_list.append('      update_knn( test_instance, training_instance, &knn_set[j * K_CONST] );')
    func_str_list.append('    }')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('  //update min_distance_list and label_list according to the new knn_set')
    func_str_list.append('  LabelType label_in = ' + str(N-1) + ';')
    func_str_list.append('  knn_vote_small(knn_set, min_distance_list, label_list, label_in);')
    func_str_list.append('')
    func_str_list.append('  OutputTmpType output_tmp1, output_tmp2;')
    func_str_list.append('')
    func_str_list.append('  for(int i=0; i<K_CONST; i++)')
    func_str_list.append('  {')
    func_str_list.append('#pragma HLS unroll')
    func_str_list.append('    output_tmp1(i*32+31, i*32) = min_distance_list[i];')
    func_str_list.append('    output_tmp2(i*32+31, i*32) = label_list[i];')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('  for(int i=OutputTmpWidth-1; i>0; i=i-32){')
    func_str_list.append('    tmp(31,0) = output_tmp1(i,i-31);')
    func_str_list.append('    Output_1.write(tmp);')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('  for(int i=OutputTmpWidth-1; i>0; i=i-32){')
    func_str_list.append('    tmp(31,0) = output_tmp2(i,i-31);')
    func_str_list.append('    Output_1.write(tmp);')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('  return;')
    func_str_list.append('}')

    return 'update_knn_i'+str(N), "\n".join(func_str_list)

def gen_update_knn_iN_header(N):
    func_str_list = []
    func_str_list.append('void update_knn_i' + str(N) + '(')
    func_str_list.append('    hls::stream<ap_uint<32>> & Input_1,')
    func_str_list.append('    hls::stream<ap_uint<32>> & Output_1')
    func_str_list.append('    );')
    func_str_list.append('#pragma map_target = HW')
    return 'update_knn_i'+str(N), "\n".join(func_str_list)


def gen_update_knn_i10_func():
    func_str_list = []
    func_str_list.append('#include "../host/typedefs.h"')
    func_str_list.append('')
    func_str_list.append('static int popcount(WholeDigitType x)')
    func_str_list.append('{')
    func_str_list.append('  // most straightforward implementation')
    func_str_list.append('  // actually not bad on FPGA')
    func_str_list.append('  int cnt = 0;')
    func_str_list.append('  for (int i = 0; i < IMAGE_SIZE; i ++ )')
    func_str_list.append('  {')
    func_str_list.append('#pragma HLS unroll')
    func_str_list.append('    cnt = cnt + x(i, i);')
    func_str_list.append('  }')
    func_str_list.append('  return cnt;')
    func_str_list.append('}')
    func_str_list.append('')
    func_str_list.append('static void update_knn( WholeDigitType test_inst, WholeDigitType train_inst, int min_distances[K_CONST] )')
    func_str_list.append('{')
    func_str_list.append('#pragma HLS inline')
    func_str_list.append('#pragma HLS array_partition variable=min_distances complete dim=0')
    func_str_list.append('')
    func_str_list.append('')
    func_str_list.append('  // Compute the difference using XOR')
    func_str_list.append('  WholeDigitType diff = test_inst ^ train_inst;')
    func_str_list.append('')
    func_str_list.append('  int dist = 0;')
    func_str_list.append('')
    func_str_list.append('  dist = popcount(diff);')
    func_str_list.append('')
    func_str_list.append('  int max_dist = 0;')
    func_str_list.append('  int max_dist_id = 0;')
    func_str_list.append('  int k = 0;')
    func_str_list.append('')
    func_str_list.append('  // Find the max distance')
    func_str_list.append('  FIND_MAX_DIST: for ( int k = 0; k < K_CONST; ++k )')
    func_str_list.append('  {')
    func_str_list.append('    if ( min_distances[k] > max_dist )')
    func_str_list.append('    {')
    func_str_list.append('      max_dist = min_distances[k];')
    func_str_list.append('      max_dist_id = k;')
    func_str_list.append('    }')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('  // Replace the entry with the max distance')
    func_str_list.append('  if ( dist < max_dist )')
    func_str_list.append('    min_distances[max_dist_id] = dist;')
    func_str_list.append('')
    func_str_list.append('  return;')
    func_str_list.append('}')
    func_str_list.append('')
    func_str_list.append('')
    func_str_list.append('static void knn_vote_small(int knn_set[OP_SIZE * K_CONST],')
    func_str_list.append('                           int min_distance_list[K_CONST],')
    func_str_list.append('                           int label_list[K_CONST],')
    func_str_list.append('                           LabelType label_in)')
    func_str_list.append('{')
    func_str_list.append('#pragma HLS inline')
    func_str_list.append('#pragma HLS array_partition variable=knn_set complete dim=0')
    func_str_list.append('// final K nearest neighbors')
    func_str_list.append('#pragma HLS array_partition variable=min_distance_list complete dim=0')
    func_str_list.append('// labels for the K nearest neighbors')
    func_str_list.append('#pragma HLS array_partition variable=label_list complete dim=0')
    func_str_list.append('')
    func_str_list.append('  int pos = 1000;')
    func_str_list.append('')
    func_str_list.append('  // go through all the lanes')
    func_str_list.append('  // do an insertion sort to keep a sorted neighbor list')
    func_str_list.append('  LANES: for (int i = 0; i < OP_SIZE; i ++ )')
    func_str_list.append('  {')
    func_str_list.append('    INSERTION_SORT_OUTER: for (int j = 0; j < K_CONST; j ++ )')
    func_str_list.append('    {')
    func_str_list.append('      #pragma HLS pipeline')
    func_str_list.append('      pos = 1000;')
    func_str_list.append('      INSERTION_SORT_INNER: for (int r = 0; r < K_CONST; r ++ )')
    func_str_list.append('      {')
    func_str_list.append('        #pragma HLS unroll')
    func_str_list.append('        pos = ((knn_set[i*K_CONST+j] < min_distance_list[r]) && (pos > K_CONST)) ? r : pos;')
    func_str_list.append('      }')
    func_str_list.append('')
    func_str_list.append('      INSERT: for (int r = K_CONST ;r > 0; r -- )')
    func_str_list.append('      {')
    func_str_list.append('        #pragma HLS unroll')
    func_str_list.append('        if(r-1 > pos)')
    func_str_list.append('        {')
    func_str_list.append('          min_distance_list[r-1] = min_distance_list[r-2];')
    func_str_list.append('          label_list[r-1] = label_list[r-2];')
    func_str_list.append('        }')
    func_str_list.append('        else if (r-1 == pos)')
    func_str_list.append('        {')
    func_str_list.append('          min_distance_list[r-1] = knn_set[i*K_CONST+j];')
    func_str_list.append('          label_list[r-1] = label_in;')
    func_str_list.append('        }')
    func_str_list.append('      }')
    func_str_list.append('    }')
    func_str_list.append('  }')
    func_str_list.append('}')
    func_str_list.append('')
    func_str_list.append('static LabelType knn_vote_final(int label_list[K_CONST])')
    func_str_list.append('{')
    func_str_list.append('#pragma HLS array_partition variable=label_list complete dim=0')
    func_str_list.append('#pragma HLS inline')
    func_str_list.append('')
    func_str_list.append('  int vote_list[10];')
    func_str_list.append('#pragma HLS array_partition variable=vote_list complete dim=0')
    func_str_list.append('')
    func_str_list.append('')
    func_str_list.append('  INIT_2: for (int i = 0;i < 10; i ++ )')
    func_str_list.append('  {')
    func_str_list.append('#pragma HLS unroll')
    func_str_list.append('    vote_list[i] = 0;')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('  // vote')
    func_str_list.append('  INCREMENT: for (int i = 0;i < K_CONST; i ++ )')
    func_str_list.append('  {')
    func_str_list.append('#pragma HLS pipeline')
    func_str_list.append('    vote_list[label_list[i]] += 1;')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('  LabelType max_vote;')
    func_str_list.append('  max_vote = 0;')
    func_str_list.append('')
    func_str_list.append('  // find the maximum value')
    func_str_list.append('  VOTE: for (int i = 0;i < 10; i ++ )')
    func_str_list.append('  {')
    func_str_list.append('#pragma HLS unroll')
    func_str_list.append('    if(vote_list[i] >= vote_list[max_vote])')
    func_str_list.append('    {')
    func_str_list.append('      max_vote = i;')
    func_str_list.append('    }')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('  return max_vote;')
    func_str_list.append('')
    func_str_list.append('}')
    func_str_list.append('')
    func_str_list.append('')
    func_str_list.append('')
    func_str_list.append('void update_knn_i10(hls::stream<ap_uint<32> > & Input_1, hls::stream<ap_uint<256> > & Output_1)')
    func_str_list.append('{')
    func_str_list.append('#pragma HLS INTERFACE axis register port=Input_1')
    func_str_list.append('#pragma HLS INTERFACE axis register port=Output_1')
    func_str_list.append('')
    func_str_list.append('static WholeDigitType training_set [NUM_TRAINING / NUM_OPS];')
    func_str_list.append('const int unroll_factor = OP_SIZE;')
    func_str_list.append('#pragma HLS array_partition variable=training_set block factor=unroll_factor dim=0')
    func_str_list.append('')
    func_str_list.append('static WholeDigitType test_instance;')
    func_str_list.append('static unsigned char results_holder[2048];')
    func_str_list.append('')
    func_str_list.append('static int knn_set[K_CONST*OP_SIZE];')
    func_str_list.append('#pragma HLS array_partition variable=knn_set complete dim=0')
    func_str_list.append('')
    func_str_list.append('WholeDigitType data_temp;')
    func_str_list.append('static int index = 0;')
    func_str_list.append('')
    func_str_list.append('if (index == 0)')
    func_str_list.append('{')
    func_str_list.append('  //Store the local training set')
    func_str_list.append('  STORE_LOCAL: for(int i = 0; i < NUM_TRAINING / NUM_OPS; i++)')
    func_str_list.append('  {')
    func_str_list.append('#pragma HLS pipeline')
    func_str_list.append('')
    func_str_list.append('    training_set[i](255, 224) =Input_1.read();')
    func_str_list.append('    training_set[i](223, 192) =Input_1.read();')
    func_str_list.append('    training_set[i](191, 160) =Input_1.read();')
    func_str_list.append('    training_set[i](159, 128) =Input_1.read();')
    func_str_list.append('    training_set[i](127,  96) =Input_1.read();')
    func_str_list.append('    training_set[i](95,   64) =Input_1.read();')
    func_str_list.append('    training_set[i](63,   32) =Input_1.read();')
    func_str_list.append('    training_set[i](31,    0) =Input_1.read();')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('  //Output_1.write(2001);')
    func_str_list.append('  index = 1;')
    func_str_list.append('}')
    func_str_list.append('')
    func_str_list.append('  for(int j=IMAGE_WIDTH-1; j>0; j=j-32){')
    func_str_list.append('    test_instance(j, j-31) =Input_1.read();')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('  int min_distance_list[K_CONST];')
    func_str_list.append('  int label_list[K_CONST];')
    func_str_list.append('')
    func_str_list.append('  OutputTmpType input_tmp1, input_tmp2;')
    func_str_list.append('')
    func_str_list.append('  for(int i=OutputTmpWidth-1; i>0; i=i-32){')
    func_str_list.append('    input_tmp1(i,i-31) = Input_1.read();')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('  for(int i=OutputTmpWidth-1; i>0; i=i-32){')
    func_str_list.append('    input_tmp2(i,i-31) = Input_1.read();')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('')
    func_str_list.append('  for(int i=0; i<K_CONST; i++)')
    func_str_list.append('  {')
    func_str_list.append('#pragma HLS unroll')
    func_str_list.append('    min_distance_list[i] = (int) input_tmp1(i*32+31, i*32);')
    func_str_list.append('    label_list[i] = (int) input_tmp2(i*32+31, i*32);')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('  // Initialize the knn set')
    func_str_list.append('  SET_KNN_SET: for ( int i = 0; i < K_CONST * OP_SIZE ; ++i )')
    func_str_list.append('  {')
    func_str_list.append('#pragma HLS unroll')
    func_str_list.append('    // Note that the max distance is 256')
    func_str_list.append('    knn_set[i] = IMAGE_SIZE;')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('  TRAINING_LOOP : for ( int i = 0; i < NUM_TRAINING / PAR_FACTOR; ++i )')
    func_str_list.append('  {')
    func_str_list.append('#pragma HLS pipeline')
    func_str_list.append('    LANES : for ( int j = 0; j < OP_SIZE; j++ )')
    func_str_list.append('    {')
    func_str_list.append('#pragma HLS unroll')
    func_str_list.append('      WholeDigitType training_instance = training_set[j * NUM_TRAINING / PAR_FACTOR + i];')
    func_str_list.append('      update_knn( test_instance, training_instance, &knn_set[j * K_CONST] );')
    func_str_list.append('    }')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('')
    func_str_list.append('  //update min_distance_list and label_list according to the new knn_set')
    func_str_list.append('  LabelType label_in = 9;')
    func_str_list.append('  knn_vote_small(knn_set, min_distance_list, label_list, label_in);')
    func_str_list.append('')
    func_str_list.append('')
    func_str_list.append('  LabelType result = knn_vote_final(label_list);')
    func_str_list.append('')
    func_str_list.append('  ap_uint<256> out_tmp;')
    func_str_list.append('  results_holder[index-1] = result;')
    func_str_list.append('  if(index == 2000) {')
    func_str_list.append('    for(int i=0; i<64; i++) {')
    func_str_list.append('      for(int j=0; j<32; j++) { // 32 = 256/8')
    func_str_list.append('        out_tmp(j*8+7, j*8) = results_holder[i*32+j];')
    func_str_list.append('      }')
    func_str_list.append('      Output_1.write(out_tmp);')
    func_str_list.append('    }')
    func_str_list.append('  }')
    func_str_list.append('')
    func_str_list.append('  index++;')
    func_str_list.append('  return;')
    func_str_list.append('}')
    return 'update_knn_i10', "\n".join(func_str_list)

def gen_update_knn_i10_header():
    func_str_list = []
    func_str_list.append('void update_knn_i10(')
    func_str_list.append('    hls::stream<ap_uint<32>> & Input_1,')
    func_str_list.append('    hls::stream<ap_uint<256>> & Output_1')
    func_str_list.append('    );')
    func_str_list.append('#pragma map_target = HW')
    return 'update_knn_i10', "\n".join(func_str_list)



# Based on ./params/cur_param.json, this file 
# generates HLS source codes (if necessary)
# updates ./host/typedefs.h, ./operators/specs.json, cur_parm.json
if __name__ == '__main__':

    op_dir = './operators'

    #####################################
    ## Extract param from cur_par.json ##
    #####################################
    with open('./params/cur_param.json', 'r') as infile:
        cur_param_dict = json.load(infile)

    # Values for PAR_FACTOR, K_CONST shuold be identical across all the ops
    for op, param_dict in cur_param_dict.items():
        if op != 'metric':
            if 'PAR_FACTOR' in param_dict:
                par_factor = param_dict['PAR_FACTOR']
            if 'K_CONST' in param_dict:
                k_val = param_dict['K_CONST']
    print(par_factor)
    print(k_val)


    ###########################################
    ## Generate src files based on cur param ##
    ###########################################

    # cpp code gen
    func_name_list = []
    ops_to_compile_list = []
    filedata_dict = {}

    func_name, filedata = gen_update_knn_i1_func()
    func_name_list.append(func_name)
    func_name, filedata_header = gen_update_knn_i1_header()
    filedata_dict[func_name] = (filedata, filedata_header)
    if needs_write_param(func_name, filedata):
        ops_to_compile_list.append(func_name)

    for i in range(2,10):
        func_name, filedata = gen_update_knn_iN_func(i)
        func_name_list.append(func_name)
        func_name, filedata_header = gen_update_knn_iN_header(i)
        filedata_dict[func_name] = (filedata, filedata_header)
        if needs_write_param(func_name, filedata):
            ops_to_compile_list.append(func_name)

    func_name, filedata = gen_update_knn_i10_func()
    func_name_list.append(func_name)
    func_name, filedata_header = gen_update_knn_i10_header()
    filedata_dict[func_name] = (filedata, filedata_header)
    if needs_write_param(func_name, filedata):
        ops_to_compile_list.append(func_name)

    print()
    #############################################
    ## Update cur_param.json for new operators ##
    #############################################
    # Nothing to do for this benchmark because no new operator is generated


    #################################################
    ## Update application graph (top_no_merge.cpp) ##
    #################################################
    # Doesn't change for this benchmark
    top_str_list = ['update_knn_i1(Input_1, knn_out1);',
                    'update_knn_i2(knn_out1, knn_out2);',
                    'update_knn_i3(knn_out2, knn_out3);',
                    'update_knn_i4(knn_out3, knn_out4);',
                    'update_knn_i5(knn_out4, knn_out5);',
                    'update_knn_i6(knn_out5, knn_out6);',
                    'update_knn_i7(knn_out6, knn_out7);',
                    'update_knn_i8(knn_out7, knn_out8);',
                    'update_knn_i9(knn_out8, knn_out9);',
                    'update_knn_i10(knn_out9, Output_1);']
    with open('./host/top_no_merge.cpp', 'w') as outfile:
        outfile.write("\n".join(top_str_list))

    # Check all the functions are instantiated in top_no_merge.cpp
    top_func_name_list = []
    with open('./host/top_no_merge.cpp', 'r') as infile:
        lines = infile.readlines()
        for line in lines:
            func_name = line.split('(')[0]
            top_func_name_list.append(func_name)
    assert(top_func_name_list.sort() == func_name_list.sort())


    #####################
    ## Perform merging ##
    #####################
    operator_list = list(cur_param_dict.keys())
    operator_list.remove("metric")
    # operator_list = merge_op_list()

    # Modify cur_param_dict, ops_to_compile_list and WRITE .cpp files
    merged_top_str_dict = perform_merging(operator_list, cur_param_dict, ops_to_compile_list, filedata_dict)


    # Save cur_param_dict updated by perform_merging
    with open('./params/cur_param.json', 'w') as outfile:
        json.dump(cur_param_dict, outfile, sort_keys=True, indent=4)

    # Save ops_to_compile.json, used to record compile time
    with open('./params/ops_to_compile.json', 'w') as outfile:
        json.dump(ops_to_compile_list, outfile, sort_keys=True, indent=4)    


    # Modify typedefs.h
    filedata = ''
    with open('./host/typedefs.h', 'r') as infile:
        lines = infile.readlines()
    for line in lines:
        if line.startswith('#define PAR_FACTOR '):
            line = '#define PAR_FACTOR ' + str(par_factor) + '\n'
        elif line.startswith('#define K_CONST '):
            line = '#define K_CONST ' + str(k_val) + '\n'
        filedata += line
    with open('./host/typedefs.h', 'w') as outfile:
        outfile.write(filedata)



    #######################################################
    ## Update application graph (top.cpp) - post merging ##
    #######################################################
    post_merging_top_str_list = top_str_list
    for op_tup in merged_top_str_dict:
        for op in op_tup:
            for line in top_str_list:
                if line.startswith(op + '('):
                    post_merging_top_str_list.remove(line)

    for op_tup in merged_top_str_dict:
        merged_top_str = merged_top_str_dict[op_tup]
        post_merging_top_str_list.append(merged_top_str)

    with open('./host/top.cpp', 'w') as outfile:
        outfile.write("\n".join(post_merging_top_str_list))


    ###############################################
    ## Update specs.json -- may be removed later ##
    ###############################################
    post_merging_func_name_list = []
    for line in post_merging_top_str_list:
        func_name = line.split('(')[0]
        post_merging_func_name_list.append(func_name)

    spec_dict = {}
    for func_name in post_merging_func_name_list:
        spec_dict[func_name] = {}
        spec_dict[func_name]['kernel_clk'] = cur_param_dict[func_name]['kernel_clk']
        spec_dict[func_name]['num_leaf_interface'] = cur_param_dict[func_name]['num_leaf_interface']
    with open(op_dir + '/specs.json', 'w') as outfile:
        json.dump(spec_dict, outfile, sort_keys=True, indent=4)

